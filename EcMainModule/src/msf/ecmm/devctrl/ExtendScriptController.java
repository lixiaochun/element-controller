/*
 * Copyright(c) 2019 Nippon Telegraph and Telephone Corporation
 */

package msf.ecmm.devctrl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import msf.ecmm.common.CommandExecutor;
import msf.ecmm.common.CommonDefinitions;
import msf.ecmm.common.LogFormatter;
import msf.ecmm.common.log.MsfLogger;
import msf.ecmm.config.PingOspfNeighborConfiguration;
import msf.ecmm.devctrl.pojo.PingData;

/**
 * The ping operation between equipments. 
 */
public class ExtendScriptController {

  /** Logger. */
  protected static final MsfLogger logger = new MsfLogger();

  /** shell is unexecuted. */
  private static final String UNEXECUTED = "unexecuted";

  /** The sh for the ping execution is successful. */
  private static final int PING_OK = 0;

  /** 
   * The SSH login to the node excuting the ping has not been successful.
   *ï¼ˆThe return code generated by the sh script is defined).   
   */
  private static final int SSH_LOGIN_NG = 255;

  /**
   * The ping between the nodes is executed. 
   *
   * @param loginIp 
   *          Login IP
   * @param pingList
   *          IP List to execute ping
   * @param pass
   *          Login password
   * @param user
   *          Login user name
   * @param pingShFile
   *          shell file name
   * @return Result
   */
  public PingData executePing(String loginIp, String pingList, String pass, String user, String pingShFile) {

    logger.trace(CommonDefinitions.START);
    logger.debug(loginIp + ", " + pingList + ", " + pass + ", " + user + ", " + pingShFile);

    PingData result = new PingData();
    result.setNodeIp(loginIp);

    String scriptPath = PingOspfNeighborConfiguration.getInstance().get(String.class,
        PingOspfNeighborConfiguration.PING_SCRIPT_DIR_PATH);
    int pingRetryNum = PingOspfNeighborConfiguration.getInstance().get(Integer.class,
        PingOspfNeighborConfiguration.PING_RETRY_NUM);

    String[] pingCommand = { scriptPath + "/" + pingShFile, loginIp, pingList, user, pass,
        String.valueOf(pingRetryNum) };
    List<String> stdList = new ArrayList<String>();
    List<String> errList = new ArrayList<String>();
    int ret = CommandExecutor.exec(pingCommand, stdList, errList);

    Map<String, String> resultMap = result.getResult();

    if (ret != PING_OK) {
      if (ret == SSH_LOGIN_NG) {
        logger.warn(LogFormatter.out.format(LogFormatter.MSG_405097, loginIp));
      }
      String[] pingArray = pingList.split("\\+");
      for (String ipSet : pingArray) {
        resultMap.put(ipSet, UNEXECUTED);
      }
      logger.error(LogFormatter.out.format(LogFormatter.MSG_505096, pingCommand[0]));
    } else {
      Gson gson = new Gson();
      resultMap = gson.fromJson(stdList.get(0), new TypeToken<HashMap<String, String>>() {
      }.getType());
    }
    result.setResult(resultMap);

    logger.debug(result);
    logger.trace(CommonDefinitions.END);

    return result;
  }

}
